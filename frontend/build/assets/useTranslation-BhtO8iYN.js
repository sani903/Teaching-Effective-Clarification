import{r as l}from"./chunk-NISHYRIK-CgksP-ke.js";import{g as A,c as P}from"./open-hands-axios-DsgPCc-0.js";const j=(e,t,n,a)=>{const o=[n,{code:t,...a||{}}];if(e?.services?.logger?.forward)return e.services.logger.forward(o,"warn","react-i18next::",!0);N(o[0])&&(o[0]=`react-i18next:: ${o[0]}`),e?.services?.logger?.warn?e.services.logger.warn(...o):console?.warn&&console.warn(...o)},O={},x=(e,t,n,a)=>{N(n)&&O[n]||(N(n)&&(O[n]=new Date),j(e,t,n,a))},v=(e,t)=>()=>{if(e.isInitialized)t();else{const n=()=>{setTimeout(()=>{e.off("initialized",n)},0),t()};e.on("initialized",n)}},b=(e,t,n)=>{e.loadNamespaces(t,v(e,n))},R=(e,t,n,a)=>{if(N(n)&&(n=[n]),e.options.preload&&e.options.preload.indexOf(t)>-1)return b(e,n,a);n.forEach(o=>{e.options.ns.indexOf(o)<0&&e.options.ns.push(o)}),e.loadLanguages(t,v(e,a))},k=(e,t,n={})=>!t.languages||!t.languages.length?(x(t,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:t.languages}),!0):t.hasLoadedNamespace(e,{lng:n.lng,precheck:(a,o)=>{if(n.bindI18n&&n.bindI18n.indexOf("languageChanging")>-1&&a.services.backendConnector.backend&&a.isLanguageChangingTo&&!o(a.isLanguageChangingTo,e))return!1}}),N=e=>typeof e=="string",F=e=>typeof e=="object"&&e!==null,M=l.createContext();class U{constructor(){this.usedNamespaces={}}addUsedNamespaces(t){t.forEach(n=>{this.usedNamespaces[n]||(this.usedNamespaces[n]=!0)})}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}const _=(e,t)=>{const n=l.useRef();return l.useEffect(()=>{n.current=e},[e,t]),n.current},z=(e,t,n,a)=>e.getFixedT(t,n,a),G=(e,t,n,a)=>l.useCallback(z(e,t,n,a),[e,t,n,a]),W=(e,t={})=>{const{i18n:n}=t,{i18n:a,defaultNS:o}=l.useContext(M)||{},s=n||a||A();if(s&&!s.reportNamespaces&&(s.reportNamespaces=new U),!s){x(s,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const i=(u,f)=>N(f)?f:F(f)&&N(f.defaultValue)?f.defaultValue:Array.isArray(u)?u[u.length-1]:u,c=[i,{},!1];return c.t=i,c.i18n={},c.ready=!1,c}s.options.react?.wait&&x(s,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const m={...P(),...s.options.react,...t},{useSuspense:E,keyPrefix:T}=m;let r=o||s.options?.defaultNS;r=N(r)?[r]:r||["translation"],s.reportNamespaces.addUsedNamespaces?.(r);const d=(s.isInitialized||s.initializedStoreOnce)&&r.every(i=>k(i,s,m)),L=G(s,t.lng||null,m.nsMode==="fallback"?r:r[0],T),C=()=>L,y=()=>z(s,t.lng||null,m.nsMode==="fallback"?r:r[0],T),[S,p]=l.useState(C);let w=r.join();t.lng&&(w=`${t.lng}${w}`);const I=_(w),g=l.useRef(!0);l.useEffect(()=>{const{bindI18n:i,bindI18nStore:c}=m;g.current=!0,!d&&!E&&(t.lng?R(s,t.lng,r,()=>{g.current&&p(y)}):b(s,r,()=>{g.current&&p(y)})),d&&I&&I!==w&&g.current&&p(y);const u=()=>{g.current&&p(y)};return i&&s?.on(i,u),c&&s?.store.on(c,u),()=>{g.current=!1,s&&i&&i?.split(" ").forEach(f=>s.off(f,u)),c&&s&&c.split(" ").forEach(f=>s.store.off(f,u))}},[s,w]),l.useEffect(()=>{g.current&&d&&p(C)},[s,T,d]);const h=[S,s,d];if(h.t=S,h.i18n=s,h.ready=d,d||!d&&!E)return h;throw new Promise(i=>{t.lng?R(s,t.lng,r,()=>i()):b(s,r,()=>i())})};export{M as I,j as a,F as b,N as i,W as u,x as w};
